---
title: "R Notebook"
output: 
  html_notebook:
    toc: true
---

```{r setup, include = FALSE}
knitr::opts_knit$set(root.dir = PROJHOME)
```

In this document, I will create a graph that shows the distribution of MLGs
across populations

```{r}
library('tidyverse')
library('assertr')
library('poppr')
library('igraph')
library("ggraph")
```

## Loading data and assertions





```{r read_data}
dat <- read.genalex("../Analysis4 ForManu/A2_Copy4 EUR_AUS_forManu.csv", ploidy = 1)
splitStrata(dat) <- ~Isolate/Severity/MCG/Region/Source/Year/Host
dat
```

The incoming strata includes both Severity and Isolate. Since these are not
necessary for delimiting the strata, we will place them in the "other" slot
after converting Severity to numeric. Placing this information in the "other"
slot ensures that these data will travel with the object.

```{r fix_strata}
dat_strata <- strata(dat) %>%
  mutate_all(as.character) %>%
  mutate(Severity = as.numeric(Severity))
strata(dat)     <- select(dat_strata, -Severity, -Isolate)
indNames(dat)   <- dat_strata$Isolate
other(dat)$meta <- select(dat_strata, Severity, Isolate)
```

```{r}
setPop(dat) <- ~Region
dat
```

## Crossing populations


We can use `mlg.crosspop()` to tabulte which MLGs cross populations.

I realized that it's possible to use an MLG table with matrix multiplication to
get an adjency matrix.

```{r}
datmlg  <- mlg.table(dat, plot = FALSE) > 0 # presence/absence of MLG
crosses <- mlg.crosspop(dat, quiet = TRUE, df = TRUE) %>% tbl_df()
adjmat  <- datmlg %*% t(datmlg) 
cols    <- sort(colnames(adjmat))
adjmat  <- adjmat[cols, cols]
adjmat
crosses
```


Now that we have the adjacency matrix, we can use it to construct our graph:

```{r, fig.width = 10, fig.height = 10}
g           <- graph_from_adjacency_matrix(adjmat, mode = "undirected", diag = FALSE)
V(g)$size   <- diag(adjmat)
g           <- delete_vertices(g, degree(g) == 0)
shared_mlg  <- (crosses %>% group_by(Population) %>% summarize(n = n()))$n
V(g)$weight <- 1 - shared_mlg/V(g)$size
el          <- as_adj_edge_list(g)
el          <- el[lengths(el) > 0]
popgraphs <- setNames(vector(mode = "list", length = length(el)), names(el))
for (v in names(el)){
  idx  <- el[[v]]
  mlgs <- crosses %>%           # How to get all MLGs from a single population:
    filter(Population == v) %>%         # Grab only the population e and then
    select(MLG) %>%                     # remove everything but the MLGs to do an
    inner_join(crosses, by = "MLG") %>% # inner join of the original list and then
    filter(Population != v) %>%         # remove the query population to give
    arrange(Population)                 # the neigboring populations in order.
  MLGS <- as.character(mlgs$MLG)
  E(g)[idx]$label  <- substr(MLGS, 5, nchar(MLGS))
  E(g)[idx]$weight <- as.integer(table(MLGS)[MLGS]) # weight == n populations visited
  popgraphs[[v]]   <- subgraph.edges(g, eids = idx)
}
par(mfrow = c(3, 4))
for (i in names(popgraphs)){
  pg <- popgraphs[[i]]
  labs <- ifelse(E(pg)$weight > 1, E(pg)$label, NA)
  labs <- ifelse(duplicated(labs), NA, labs)
  plot(pg, 
       main = i, 
       layout = layout_as_star(pg, center = i), 
       edge.width = E(pg)$weight,
       edge.label = labs)
}
par(mfrow = c(1, 1))
center_node <- degree(g) %>% which.max() %>% names()

new_layout <- structure(c(1, 0.809016994374947, 0.309016994374947, -0.309016994374947, 
-0.809016994374947, -1, -0.809016994374947, -0.309016994374948, 
0, 0.309016994374947, 0.809016994374947, 0, 0.587785252292473, 
0.951056516295154, 0.951056516295154, 0.587785252292473, 1.22464679914735e-16, 
-0.587785252292473, -0.951056516295154, 0, -0.951056516295154, 
-0.587785252292473), .Dim = c(11L, 2L), .Dimnames = list(c("MN", 
"AU", "OR", "FR", "WA", "CA", "NE", "CO", "MI", "ND", "NY"), 
    c("x", "y")))
new_layout <- new_layout[V(g)$name, ]
g <- add_vertices(g, length(V(g)), size = V(g)$size - shared_mlg, color = "grey90")
plot(g, 
     layout = rbind(new_layout, new_layout),
     edge.width = E(g)$weight,
     edge.label = NA)

glay <- create_layout(g, "manual", node.positions = as.data.frame(rbind(new_layout, new_layout)))
ggraph(glay) +
  geom_edge_fan(aes(alpha = weight + 1)) +
  geom_node_circle(aes(r = scale(size, center = FALSE)/10, fill = size, alpha = weight)) +
  geom_node_label(aes(label = name), repel = TRUE) +
  viridis::scale_fill_viridis(option = "C") +
  coord_fixed() +
  theme_void() +
  labs(list(
    title = "Shared haplotypes across regions",
    fill = "Number of\nGenotypes",
    alpha = "Fraction of\nprivate genotpes",
    edge_alpha = "Populations\nper haploytpe",
    caption = "Outer circle: Number of haplotypes in the region\nInner Circle: Number of private haplotypes in the region"
  ))
```

