---
title: "R Notebook"
output: 
  html_notebook:
    toc: true
---

```{r setup, include = FALSE}
knitr::opts_knit$set(root.dir = PROJHOME)
```

In this document, I will create a graph that shows the distribution of MLGs
across populations

```{r}
library('tidyverse')
library('assertr')
library('poppr')
library('igraph')
library("ggraph")
```

## Loading data and assertions





```{r read_data}
dat <- read.genalex("../Analysis4 ForManu/A2_Copy4 EUR_AUS_forManu.csv", ploidy = 1)
splitStrata(dat) <- ~Isolate/Severity/MCG/Region/Source/Year/Host
dat
```

The incoming strata includes both Severity and Isolate. Since these are not
necessary for delimiting the strata, we will place them in the "other" slot
after converting Severity to numeric. Placing this information in the "other"
slot ensures that these data will travel with the object.

```{r fix_strata}
dat_strata <- strata(dat) %>%
  mutate_all(as.character) %>%
  mutate(Severity = as.numeric(Severity))
strata(dat)     <- select(dat_strata, -Severity, -Isolate)
indNames(dat)   <- dat_strata$Isolate
other(dat)$meta <- select(dat_strata, Severity, Isolate)
```

```{r}
setPop(dat) <- ~Region
dat
```

## Crossing populations


We can use `mlg.crosspop()` to tabulte which MLGs cross populations.

```{r, fig.width = 10, fig.height = 10}
make_from_to <- function(poplist){
  x <- combn(poplist, 2)
  tibble::data_frame(from = x[1, ], to = x[2, ])
}
crosses <- mlg.crosspop(dat, df = TRUE, quiet = TRUE)

pg <- 
  crosses %>%
  group_by(MLG) %>% 
  summarize(Population = list(make_from_to(Population)), Size = length(Count))
  
pop_graph <- pg %>%  unnest() %>%
  group_by(from, to) %>%
  mutate(weight = length(Size)) %>%
  ungroup() %>%
  select(from, to, weight, everything())

unchoose <- function(x) ceiling(sqrt(x * 2))


  
gcross           <- graph_from_data_frame(pop_graph, directed = FALSE)
E(gcross)$name   <- as.character(pop_graph$MLG)
E(gcross)$weight <- unchoose(table(E(gcross)$name)[E(gcross)$name])
colors <- viridis::magma(max(E(gcross)$weight) - 1, end = 0.8)
set.seed(500)
gcross %>%
  plot(., vertex.size = table(pop(clonecorrect(dat, ~Region)))[names(V(gcross))],
       edge.width = E(.)$weight - 1,
       layout = layout_as_star(., center = "MI"),
       # layout = layout_in_circle(.),
       edge.color = colors[E(.)$weight - 1])



```



```{r, fig.width = 10, fig.height = 10}
psize <- table(pop(clonecorrect(dat, ~Region)))
pops <- crosses %>%
  mutate_if(is.factor, as.character) %>%
  group_by(Population) %>%
  summarize(MLG = list(as.character(MLG))) %>%
  group_by(Population) %>%
  mutate(size = psize[unlist(Population)]) %>%
  mutate(n_private = size - lengths(MLG)) %>%
  mutate(interactions = list(pg$Population[pg$MLG %in% unlist(MLG)] %>% 
                               setNames(unlist(MLG)) %>% 
                               bind_rows(.id = "MLG") %>% 
                               distinct() %>%
                               filter(Population == from | Population == to))) %>%
  mutate(graph = map(interactions, ~select(.x, from, to, MLG) %>% 
                       rename(name = MLG) %>% 
                       graph_from_data_frame(directed = FALSE)))
pops

possible_edges <- expand.grid(from = pops$Population, to = pops$Population)
possible_edges$Population <- possible_edges$from
from_edges <- right_join(possible_edges, select(pops, Population, size)) %>% 
  tbl_df %>% 
  rename(from_size = size) %>%
  select(-Population)
to_edges <- right_join(mutate(possible_edges, Population = to), select(pops, Population, size)) %>% 
  tbl_df %>% 
  rename(to_size = size) %>%
  select(-Population)

possible_edges <- inner_join(from_edges, to_edges)
  
par(mfrow = c(3, 4))

apply(pops, 1, function(i){
    plot(i$graph, 
         layout = layout_as_star(i$graph, center = i$Population), 
         main = i$Population, 
         vertex.size = psize[names(V(i$graph))])
  })
par(mfrow = c(1, 1))

gnew <- igraph::union(pops$graph[[1]], pops$graph[-1])

glayout <- layout_as_star(gnew, center = "MI")

glayout_df <- glayout %>% 
  data.frame %>% 
  setNames(c("x", "y")) %>% 
  as.list %>% 
  c(Population = list(names(V(gnew)))) %>% 
  dplyr::as_data_frame() %>%
  inner_join(pops)
V(gnew)$size <- glayout_df$size
V(gnew)$weight <- (1 - glayout_df$n_private/glayout_df$size)
V(gnew)$color <- viridis::viridis(100)[round(V(gnew)$weight * 100)]
gnew <- add_vertices(gnew, length(V(gnew)), size = glayout_df$n_private, color = "grey90")
glayout2 <- rbind(glayout, glayout)
plot(gnew, layout = glayout2)

caps <- as_data_frame(gnew, what = "edges") %>% select(from, to) %>% 
  inner_join(possible_edges) %>% tbl_df
  
caps %>% mutate(from_size = scale(from_size, center = FALSE)/10) %>%
  mutate(to_size = scale(to_size, center = FALSE)/10) -> spac

glay <- create_layout(gnew, "manual", node.positions = as.data.frame(glayout2) %>% setNames(c("x", "y")))
ggraph(glay) +
  geom_edge_fan() +
  # geom_edge_fan2(aes(start_cap = circle(rep(spac$from_size, 2)/2, "mm"),
  #                   end_cap = circle(rep(spac$to_size, 2)/2, "mm"))) +
  geom_node_circle(aes(r = scale(size, center = FALSE)/10, fill = size, alpha = 1 - weight)) +
  geom_node_label(aes(label = name), repel = TRUE) +
  viridis::scale_fill_viridis(option = "C") +
  coord_fixed() +
  theme_void() +
  labs(list(
    title = "Shared haplotypes across regions",
    fill = "Number of\nGenotypes",
    alpha = "Fraction of private genotpes",
    caption = "Outer circle: Number of genotypes in the region\nInner Circle: Number of private genotypes in the region"
  ))
```

